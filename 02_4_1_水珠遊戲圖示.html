<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>æ°´ç éŠæˆ²</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            overflow: hidden;
        }
        #canvas {
            width: 100%;
            height: 100vh;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            display: block;
        }
        #gameOverText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            text-align: center;
            display: none;
        }
        .lifeText {
            position: absolute;
            color: white;
            font-size: 20px;
            padding: 10px;
        }
        #blueLife {
            top: 10px;
            left: 10px;
            color: #0000ff;
        }
        #redLife {
            bottom: 10px;
            right: 10px;
            color: #ff0000;
        }
    </style>
    <script>
        function emojiToImage(emoji, size) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, size/2, size/2);
            return canvas.toDataURL();
        }
    </script>
</head>
<body>
    <button id="startButton">é–‹å§‹</button>
    <div id="gameOverText"></div>
    <div id="blueLife" class="lifeText"></div>
    <div id="redLife" class="lifeText"></div>
    <script>
        const Engine = Matter.Engine,
              Render = Matter.Render,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Body = Matter.Body;

        let engine, render, world;
        let blueBox, redBox;
        let blueLife = 1000;
        let redLife = 100;
        let isDrawing = false;
        let gameState = 'start'; // start, playing, end
        let drawPoints = [];
        
        function init() {
            engine = Engine.create();
            engine.gravity.y = 1;
            world = engine.world;

            render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: '#1a1a1a'
                }
            });

            Render.run(render);
            Engine.run(engine);
        }

        function startGame() {
            gameState = 'playing';
            blueLife = 1000;
            redLife = 100;
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('gameOverText').style.display = 'none';

            // å‰µå»ºè—è‰²æ–¹å¡Š
            blueBox = Bodies.rectangle(100, 100, 80, 80, {
                isStatic: true,
                render: {
                    sprite: {
                        texture: emojiToImage('ğŸ’§', 80)
                    }
                }
            });

            // å‰µå»ºç´…è‰²æ–¹å¡Š
            redBox = Bodies.rectangle(window.innerWidth - 100, window.innerHeight - 100, 80, 80, {
                isStatic: true,
                render: {
                    sprite: {
                        texture: emojiToImage('ğŸ¯', 80)
                    }
                }
            });

            World.add(world, [blueBox, redBox]);

            // é–‹å§‹ç”Ÿæˆè—çƒ
            setInterval(() => {
                if (gameState === 'playing' && blueLife > 0) {
                    createBlueBall();
                }
            }, 100);

            // ç¢°æ’æª¢æ¸¬
            Matter.Events.on(engine, 'collisionStart', handleCollision);
            updateLifeDisplay();
        }

        function createBlueBall() {
            if (blueLife <= 0) return;
            
            const ball = Bodies.circle(
                blueBox.position.x,
                blueBox.position.y,
                10,
                {
                    friction: 0,
                    restitution: 0.8,
                    render: {
                        sprite: {
                            texture: emojiToImage('ğŸ’§', 20)
                        }
                    },
                    isBlueBall: true
                }
            );
            
            World.add(world, ball);
            blueLife--;
            updateLifeDisplay();

            // æª¢æŸ¥çƒæ˜¯å¦è¶…å‡ºè¢å¹•
            setInterval(() => {
                if (ball.position.y > window.innerHeight + 100) {
                    World.remove(world, ball);
                }
            }, 1000);
        }

        function handleCollision(event) {
            event.pairs.forEach((pair) => {
                if ((pair.bodyA.isBlueBall && pair.bodyB === redBox) ||
                    (pair.bodyB.isBlueBall && pair.bodyA === redBox)) {
                    
                    const blueBall = pair.bodyA.isBlueBall ? pair.bodyA : pair.bodyB;
                    World.remove(world, blueBall);
                    redLife--;
                    updateLifeDisplay();
                    
                    // ç´…è‰²æ–¹å¡Šé–ƒçˆæ•ˆæœ
                    redBox.render.fillStyle = '#ffffff';
                    setTimeout(() => {
                        redBox.render.fillStyle = '#ff0000';
                    }, 100);

                    checkGameOver();
                }
            });
        }

        function checkGameOver() {
            if (blueLife <= 0 || redLife <= 0) {
                gameState = 'end';
                const gameOverText = document.getElementById('gameOverText');
                gameOverText.style.display = 'block';
                
                if (blueLife <= 0) {
                    gameOverText.innerHTML = 'ä½ è¼¸äº†';
                } else {
                    gameOverText.innerHTML = `ä½ è´äº†<br>åˆ†æ•¸: ${blueLife}`;
                }

                setTimeout(() => {
                    resetGame();
                }, 5000);
            }
        }

        function resetGame() {
            World.clear(world);
            gameState = 'start';
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('gameOverText').style.display = 'none';
        }

        // ç•«ç·šåŠŸèƒ½
        let lastPoint = null;
        
        document.addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastPoint = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mousemove', (e) => {
            if (isDrawing && gameState === 'playing') {
                const currentPoint = { x: e.clientX, y: e.clientY };
                
                // è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢å’Œè§’åº¦
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // åœ¨å…©é»ä¹‹é–“å‰µå»ºå°æ–¹å¡Š
                const segments = Math.ceil(distance / 10); // æ¯10åƒç´ å‰µå»ºä¸€å€‹æ–¹å¡Š
                for (let i = 0; i < segments; i++) {
                    const x = lastPoint.x + (dx * i / segments);
                    const y = lastPoint.y + (dy * i / segments);
                    const line = Bodies.rectangle(x, y, 15, 15, {
                        isStatic: true,
                        angle: angle,
                        friction: 0,
                        render: {
                            sprite: {
                                texture: emojiToImage('â¬œ', 15)
                            }
                        }
                    });
                    World.add(world, line);
                }
                
                lastPoint = currentPoint;
            }
        });

        document.addEventListener('mouseup', () => {
            isDrawing = false;
            lastPoint = null;
        });

        // åˆå§‹åŒ–éŠæˆ²
        init();
        document.getElementById('startButton').addEventListener('click', startGame);

        // æ·»åŠ æ›´æ–°ç”Ÿå‘½å€¼é¡¯ç¤ºçš„å‡½æ•¸
        function updateLifeDisplay() {
            document.getElementById('blueLife').textContent = `ç”Ÿå‘½å€¼: ${blueLife}`;
            document.getElementById('redLife').textContent = `ç”Ÿå‘½å€¼: ${redLife}`;
        }
    </script>
</body>
</html>
