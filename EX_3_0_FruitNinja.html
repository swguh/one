<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>æ°´æœå¿è€…</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            background-image: url('./image/fruitback.jpg');
            background-size: cover;
            background-position: center;
        }
        #startButton {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            display: block;
            z-index: 100;
        }
        #gameOver {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="startButton">é–‹å§‹éŠæˆ²</button>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div id="finalScore"></div>
    </div>
    <script>
        // éŠæˆ²ç‹€æ…‹å¸¸é‡
        const GameState = {
            START: 'start',
            PLAYING: 'playing',
            GAMEOVER: 'gameover'
        };

        // æ°´æœé¡
        class Fruit {
            constructor(game) {
                this.game = game;
                this.size = 120;
                this.reset();
                // éš¨æ©Ÿé¸æ“‡æ°´æœè¡¨æƒ…
                this.emoji = ['ğŸ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸ‰', 'ğŸ‡'][Math.floor(Math.random() * 6)];
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                
                // æ·»åŠ æ°´æœé¡è‰²
                this.colors = {
                    'ğŸ': '255, 0, 0',
                    'ğŸ': '0, 255, 0',
                    'ğŸŠ': '255, 165, 0',
                    'ğŸ‹': '255, 255, 0',
                    'ğŸ‰': '255, 50, 50',
                    'ğŸ‡': '128, 0, 128'
                };
            }

            reset() {
                // å¾ç•«é¢åº•éƒ¨ä¸‹æ–¹é–‹å§‹
                this.x = Math.random() * (this.game.canvas.width - this.size);
                this.y = this.game.canvas.height + this.size;
                
                // è¨­ç½®åˆå§‹é€Ÿåº¦
                this.speedX = (Math.random() - 0.5) * 5; // å·¦å³ç§»å‹•é€Ÿåº¦

                // è¨ˆç®—éœ€è¦çš„åˆå§‹é€Ÿåº¦ä»¥é”åˆ°ç›®æ¨™é«˜åº¦
                // ç›®æ¨™é«˜åº¦ï¼šå¾é ‚éƒ¨åˆ°1/2é«˜åº¦ä¹‹é–“çš„éš¨æ©Ÿä½ç½®
                const targetMaxHeight = this.game.canvas.height * 0.1; // é›¢é ‚éƒ¨10%çš„ä½ç½®
                const targetMinHeight = this.game.canvas.height * 0.5; // ç•«é¢ä¸­é–“
                const targetHeight = targetMinHeight - (Math.random() * (targetMinHeight - targetMaxHeight));
                
                // ä½¿ç”¨é‹å‹•å­¸å…¬å¼è¨ˆç®—åˆå§‹é€Ÿåº¦
                // vÂ² = vâ‚€Â² + 2ah
                // æˆ‘å€‘è¦æ±‚çš„æ˜¯ vâ‚€
                // ç•¶åˆ°é”æœ€é«˜é»æ™‚ v = 0
                // h = ç•¶å‰ä½ç½®åˆ°ç›®æ¨™é«˜åº¦çš„è·é›¢
                const distanceToTarget = this.y - targetHeight;
                this.gravity = 0.2;
                
                // vâ‚€ = âˆš(2gh)
                this.speedY = -Math.sqrt(2 * this.gravity * distanceToTarget);
            }

            update() {
                if (this.isSliced) return;

                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.rotation += this.rotationSpeed;

                // ç¢ºä¿æ°´æœä¸æœƒè¶…å‡ºç•«é¢å·¦å³é‚Šç•Œ
                if (this.x < 0) this.speedX = Math.abs(this.speedX);
                if (this.x > this.game.canvas.width - this.size) this.speedX = -Math.abs(this.speedX);

                // æª¢æŸ¥æ˜¯å¦æ‰å‡ºç•«é¢åº•éƒ¨
                if (this.y > this.game.canvas.height + this.size && !this.isSliced) {
                    // åªæœ‰æ°´æœï¼ˆéç‚¸å½ˆï¼‰è½ä¸‹æ‰æ‰£ç”Ÿå‘½å€¼
                    if (!(this instanceof Bomb)) {
                        this.game.lives--;
                    }
                    this.reset();
                }
            }

            draw() {
                const ctx = this.game.ctx;
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.rotation);
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }

            createJuiceParticles() {
                const particles = [];
                const color = this.colors[this.emoji];
                for (let i = 0; i < 10; i++) {
                    particles.push(new JuiceParticle(
                        this.x + this.size/2,
                        this.y + this.size/2,
                        color,
                        this.game
                    ));
                }
                return particles;
            }
        }

        // ç‚¸å½ˆé¡
        class Bomb extends Fruit {
            constructor(game) {
                super(game);
                this.emoji = 'ğŸ’£';
            }
        }

        // æ»‘é¼ è»Œè·¡é¡
        class Trail {
            constructor() {
                this.points = [];
                this.maxPoints = 10;
            }

            addPoint(x, y) {
                this.points.push({ x, y });
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }
            }

            draw(ctx) {
                if (this.points.length < 2) return;
                
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        // åˆ‡å‰²ç·šé¡
        class SlashLine {
            constructor(startX, startY, endX, endY) {
                this.startX = startX;
                this.startY = startY;
                this.endX = endX;
                this.endY = endY;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        // æ°´æœæ±ç²’å­é¡
        class JuiceParticle {
            constructor(x, y, color, game) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.game = game;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * 10;
                this.speedY = (Math.random() - 0.5) * 10;
                this.gravity = 0.5;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                return this.y < this.game.canvas.height + this.size;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${this.color})`;
                ctx.fill();
            }
        }

        // éŸ³æ•ˆç®¡ç†å™¨é¡
        class SoundManager {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            playSliceSound() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(
                    300, this.audioContext.currentTime + 0.1
                );
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(
                    0.01, this.audioContext.currentTime + 0.1
                );
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playBombSound() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(
                    0.01, this.audioContext.currentTime + 0.5
                );
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.5);
            }
        }

        // æ·»åŠ é€£æ“Šç³»çµ±é¡
        class ComboSystem {
            constructor() {
                this.combo = 0;
                this.lastSliceTime = 0;
                this.comboTimeout = 1000; // 1ç§’å…§éœ€è¦é€£æ“Š
                this.maxCombo = 0;
            }

            slice() {
                const now = Date.now();
                if (now - this.lastSliceTime < this.comboTimeout) {
                    this.combo++;
                } else {
                    this.combo = 1;
                }
                this.lastSliceTime = now;
                this.maxCombo = Math.max(this.maxCombo, this.combo);
                return this.combo;
            }

            getComboMultiplier() {
                return Math.min(this.combo, 5); // æœ€é«˜5å€åˆ†æ•¸
            }

            reset() {
                this.combo = 0;
                this.lastSliceTime = 0;
                this.maxCombo = 0;
            }
        }

        // éŠæˆ²ä¸»é¡
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = GameState.START;
                this.score = 0;
                this.lives = 3;
                
                this.resize();
                this.setupEventListeners();
                
                // ä¿®æ”¹åˆå§‹åŒ–æ°´æœçš„éƒ¨åˆ†
                this.fruits = [];
                this.trail = new Trail();
                this.lastMouseX = null;
                this.lastMouseY = null;
                
                // æ·»åŠ æ°´æœç”Ÿæˆç›¸é—œçš„å±¬æ€§
                this.fruitSpawnTimer = 0;
                this.fruitSpawnInterval = 1000; // æ¯ç§’ç”Ÿæˆä¸€å€‹æ°´æœ
                this.maxFruitsOnScreen = 6; // ç•«é¢ä¸Šæœ€å¤šåŒæ™‚å­˜åœ¨çš„æ°´æœæ•¸é‡
                
                // åˆå§‹åŒ–å¹¾å€‹æ°´æœ
                for (let i = 0; i < 3; i++) {
                    this.fruits.push(new Fruit(this));
                }
                // æ·»åŠ ä¸€å€‹ç‚¸å½ˆ
                this.fruits.push(new Bomb(this));
                
                // æ·»åŠ æ–°çš„å±¬æ€§
                this.slashLines = [];
                this.juiceParticles = [];
                
                // æ·»åŠ éŸ³æ•ˆå’Œé€£æ“Šç³»çµ±
                this.soundManager = new SoundManager();
                this.comboSystem = new ComboSystem();
                
                // æ·»åŠ ç‰¹æ®Šæ°´æœç”Ÿæˆè¨ˆæ™‚å™¨
                this.specialFruitTimer = 0;
                this.specialFruitInterval = 10000; // 10ç§’
                
                // æ·»åŠ é›£åº¦ç›¸é—œå±¬æ€§
                this.gameStartTime = 0;
                this.difficultyLevel = 1;
                
                // æ·»åŠ èƒŒæ™¯éŸ³æ¨‚
                this.bgMusic = new Audio('./music/gamemusic.mp3');
                this.bgMusic.loop = true; // å¾ªç’°æ’­æ”¾
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resize());
                document.getElementById('startButton').addEventListener('click', () => this.startGame());
                
                // ä¿®æ”¹æ»‘é¼ äº‹ä»¶è™•ç†
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.state !== GameState.PLAYING) return;
                    
                    const currentX = e.clientX;
                    const currentY = e.clientY;
                    
                    this.trail.addPoint(currentX, currentY);
                    
                    // ç¢ºä¿æœ‰ä¸Šä¸€å€‹é»æ‰é€²è¡Œåˆ‡å‰²æª¢æ¸¬
                    if (this.lastMouseX !== null && this.lastMouseY !== null) {
                        // å‰µå»ºåˆ‡å‰²ç·š
                        this.slashLines.push(new SlashLine(
                            this.lastMouseX,
                            this.lastMouseY,
                            currentX,
                            currentY
                        ));
                        
                        // æª¢æŸ¥ç¢°æ’
                        this.checkLineCollisions(
                            this.lastMouseX,
                            this.lastMouseY,
                            currentX,
                            currentY
                        );
                    }
                    
                    this.lastMouseX = currentX;
                    this.lastMouseY = currentY;
                });

                // æ·»åŠ æ»‘é¼ é›¢é–‹å’Œæ»‘é¼ æŒ‰ä¸‹ä»¶è™•ç†
                this.canvas.addEventListener('mouseout', () => {
                    this.lastMouseX = null;
                    this.lastMouseY = null;
                });

                this.canvas.addEventListener('mouseenter', () => {
                    this.lastMouseX = null;
                    this.lastMouseY = null;
                });
            }

            startGame() {
                this.state = GameState.PLAYING;
                this.score = 0;
                this.lives = 3;
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                this.comboSystem.reset();
                this.specialFruitTimer = Date.now();
                this.gameStartTime = Date.now();
                this.difficultyLevel = 1;
                
                // æ’­æ”¾èƒŒæ™¯éŸ³æ¨‚
                this.bgMusic.play().catch(error => {
                    console.log("éŸ³æ¨‚æ’­æ”¾å¤±æ•—:", error);
                });
                
                this.gameLoop();
            }

            checkCollisions(mouseX, mouseY) {
                // ç°¡å–®çš„é»ç¢°æª¢æ¸¬
                this.fruits.forEach(fruit => {
                    if (!fruit.isSliced) {
                        const dx = mouseX - (fruit.x + fruit.size/2);
                        const dy = mouseY - (fruit.y + fruit.size/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < fruit.size/2) {
                            if (fruit instanceof Bomb) {
                                this.lives--;
                                fruit.reset();
                                this.shakeScreen();
                                this.soundManager.playBombSound();
                                this.comboSystem.reset();
                            } else {
                                this.score += 10;
                                fruit.isSliced = true;
                                setTimeout(() => fruit.reset(), 1000);
                            }
                        }
                    }
                });
            }

            shakeScreen() {
                this.canvas.style.transform = 'translate(10px, 10px)';
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(-10px, -10px)';
                    setTimeout(() => {
                        this.canvas.style.transform = 'translate(0, 0)';
                    }, 50);
                }, 50);
            }

            checkLineCollisions(x1, y1, x2, y2) {
                // ç¢ºä¿æ‰€æœ‰åƒæ•¸éƒ½æ˜¯æœ‰æ•ˆçš„æ•¸å­—
                if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                    return;
                }

                this.fruits.forEach(fruit => {
                    if (!fruit.isSliced) {
                        const fruitCenterX = fruit.x + fruit.size/2;
                        const fruitCenterY = fruit.y + fruit.size/2;
                        
                        if (this.lineCircleCollision(
                            x1, y1, x2, y2,
                            fruitCenterX, fruitCenterY,
                            fruit.size/2
                        )) {
                            if (fruit instanceof Bomb) {
                                this.lives--;
                                fruit.reset();
                                this.shakeScreen();
                                this.soundManager.playBombSound();
                                this.comboSystem.reset();
                            } else {
                                const comboMultiplier = this.comboSystem.getComboMultiplier();
                                const baseScore = fruit.isSpecial ? 30 : 10;
                                this.score += baseScore * comboMultiplier;
                                
                                const combo = this.comboSystem.slice();
                                if (combo > 1) {
                                    this.showComboText(fruit.x, fruit.y, combo);
                                }
                                
                                fruit.isSliced = true;
                                this.juiceParticles.push(...fruit.createJuiceParticles());
                                this.soundManager.playSliceSound();
                                fruit.reset();
                            }
                        }
                    }
                });
            }

            lineCircleCollision(x1, y1, x2, y2, cx, cy, r) {
                // ç¢ºä¿æ‰€æœ‰åƒæ•¸éƒ½æ˜¯æœ‰æ•ˆçš„æ•¸å­—
                if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || 
                    isNaN(cx) || isNaN(cy) || isNaN(r)) {
                    return false;
                }

                // è¨ˆç®—ç·šæ®µåˆ°åœ“å¿ƒçš„æœ€çŸ­è·é›¢
                const lineLength = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                if (lineLength === 0) return false;  // é˜²æ­¢é™¤ä»¥é›¶

                const dot = (((cx-x1)*(x2-x1) + (cy-y1)*(y2-y1)) / (lineLength**2));
                const closestX = x1 + (dot * (x2-x1));
                const closestY = y1 + (dot * (y2-y1));
                
                // æª¢æŸ¥æœ€è¿‘é»æ˜¯å¦åœ¨ç·šæ®µä¸Š
                if (dot < 0) {
                    return Math.sqrt((cx-x1)**2 + (cy-y1)**2) <= r;
                }
                if (dot > 1) {
                    return Math.sqrt((cx-x2)**2 + (cy-y2)**2) <= r;
                }
                
                // è¨ˆç®—æœ€çŸ­è·é›¢
                const distance = Math.sqrt((cx-closestX)**2 + (cy-closestY)**2);
                return distance <= r;
            }

            showComboText(x, y, combo) {
                const ctx = this.ctx;
                ctx.save();
                
                // æ ¹æ“šé€£æ“Šæ•¸æ”¹è®Šé¡è‰²å’Œå¤§å°
                const fontSize = Math.min(48 + combo * 2, 72);
                const colors = ['yellow', 'orange', 'red', 'purple', 'blue'];
                const colorIndex = Math.min(combo - 1, colors.length - 1);
                
                ctx.font = `${fontSize}px Arial`;
                ctx.fillStyle = colors[colorIndex];
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                
                const text = `${combo}x COMBO!`;
                ctx.strokeText(text, x, y - 50);
                ctx.fillText(text, x, y - 50);
                
                ctx.restore();
            }

            updateDifficulty() {
                // æ¯60ç§’å¢åŠ ä¸€æ¬¡é›£åº¦
                const gameTime = (Date.now() - this.gameStartTime) / 1000;
                this.difficultyLevel = Math.floor(gameTime / 60) + 1;
                
                // æ ¹æ“šé›£åº¦èª¿æ•´ç”Ÿæˆé–“éš”
                this.fruitSpawnInterval = Math.max(1000 - (this.difficultyLevel * 100), 400);
                this.maxFruitsOnScreen = Math.min(6 + Math.floor(this.difficultyLevel / 2), 10);
            }

            gameLoop() {
                if (this.state !== GameState.PLAYING) return;

                // æ¸…ç©ºç•«é¢
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // ç”Ÿæˆæ–°æ°´æœ
                const now = Date.now();
                if (now - this.fruitSpawnTimer > this.fruitSpawnInterval) {
                    this.fruitSpawnTimer = now;
                    
                    const activeFruits = this.fruits.filter(f => !f.isSliced).length;
                    
                    if (activeFruits < this.maxFruitsOnScreen) {
                        if (Math.random() < 0.97) {
                            this.fruits.push(new Fruit(this));
                        } else {
                            this.fruits.push(new Bomb(this));
                        }
                    }
                }

                // æ›´æ–°å’Œç¹ªè£½åˆ‡å‰²ç·š
                this.slashLines.forEach(line => line.draw(this.ctx));
                // æ¯å¹€æ¸…é™¤æ‰€æœ‰åˆ‡å‰²ç·š
                this.slashLines = [];

                // æ›´æ–°å’Œç¹ªè£½æ°´æœæ±ç²’å­
                this.juiceParticles = this.juiceParticles.filter(particle => {
                    const alive = particle.update();
                    if (alive) particle.draw(this.ctx);
                    return alive;
                });

                // æ›´æ–°å’Œç¹ªè£½æ°´æœ
                this.fruits = this.fruits.filter(fruit => {
                    if (fruit.y > this.canvas.height + fruit.size * 2) {
                        return false;
                    }
                    fruit.update();
                    fruit.draw();
                    return true;
                });

                // ç¹ªè£½è»Œè·¡
                this.trail.draw(this.ctx);

                // ç¹ªè£½UI
                this.drawUI();

                // æª¢æŸ¥éŠæˆ²çµæŸ
                if (this.lives <= 0) {
                    this.gameOver();
                    return;
                }

                this.updateDifficulty();

                requestAnimationFrame(() => this.gameLoop());
            }

            drawUI() {
                this.ctx.fillStyle = 'white';
                this.ctx.font = '30px Arial';
                this.ctx.fillText(`åˆ†æ•¸: ${this.score}`, 20, 40);
                
                // é¡¯ç¤ºç•¶å‰é€£æ“Šæ•¸
                if (this.comboSystem.combo > 1) {
                    this.ctx.fillText(`é€£æ“Š: ${this.comboSystem.combo}x`, 20, 80);
                }
                
                // é¡¯ç¤ºæœ€é«˜é€£æ“Šæ•¸
                this.ctx.fillText(`æœ€é«˜é€£æ“Š: ${this.comboSystem.maxCombo}x`, 20, 120);
                
                // ç¹ªè£½ç”Ÿå‘½å€¼
                const hearts = 'â¤ï¸'.repeat(this.lives);
                this.ctx.font = '30px Arial';
                this.ctx.fillText(hearts, this.canvas.width - 120, 40);
            }

            gameOver() {
                this.state = GameState.GAMEOVER;
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = 
                    `æœ€çµ‚åˆ†æ•¸: ${this.score}\næœ€é«˜é€£æ“Š: ${this.comboSystem.maxCombo}x`;
                
                // åœæ­¢èƒŒæ™¯éŸ³æ¨‚
                this.bgMusic.pause();
                this.bgMusic.currentTime = 0;
                
                setTimeout(() => {
                    document.getElementById('startButton').style.display = 'block';
                    this.state = GameState.START;
                }, 3000);
            }
        }

        // åˆå§‹åŒ–éŠæˆ²
        const game = new Game();
    </script>
</body>
</html>
